---
layout:     post
title:      "Elixir"
date:       2018-06-19 09:41:33 +0200
categories: coding
---

I've surfed on the wave of the enthusiasm of Dave Thomas about the Elixir language, slurping both his book (just fair) and the Manning's one (very good).

I have been impressed by how the OTP infrastructure guarantees resilience over distributed systems.

I enjoyed the functional programming approach: everything immutable, first class functions, iteration by recursion and pattern matching.

I was struck by the elegance of Elixir (well, Erlang) actors model and how they can achieve parallelism without regrets.

I liked the meta programming features offered by its pretty powerful macros (although it leads to proliferation of sub-languages).

I really like the idea of liking Elixir, but i don't.

When it was time to write Elixir code i simply didn't enjoy the journey: on one side i felt it lacks the code organization granted by object oriented design (which it tries to emulate), on the other side it is not as straight as other pure functional languages (Haskell, Clojure or its sibling, Erlang).

That's why, i suspect, Elixir failed both in rivaling Ruby (Rails) as startups first choice and in replacing Erlang in the niches where it continues to excel.
